#!/usr/bin/env python

from __future__ import print_function
from __future__ import absolute_import

import os, sys, getopt
from subprocess import call, Popen, PIPE
import sipconfig
import platform
useqt5 = True

try:
    import PyQt5.QtCore

except:
    useqt5 = False
    from PyQt4 import pyqtconfig
    from PyQt4.QtCore import QT_VERSION_STR

from distutils.sysconfig import get_python_lib

try:
    opts, remargs = getopt.getopt(sys.argv[1:], 'f:')
    for opt in opts:
        if (opt[0] == '-f'):
            mylibSipFile = opt[1]

except getopt.GetoptError as args:
    print(("options error: ", args))
    exit(-1)

# The name of the SIP build file generated by SIP and used by the build
# system.
build_file = "./mylib.sbf"

# Get the PyQt configuration information.
if useqt5:
    from distutils import spawn
    config = sipconfig.Configuration()
    sipbin =  spawn.find_executable("sip")
    pconfig = PyQt5.QtCore.PYQT_CONFIGURATION

    # In the fedora27 base image, the qmake executable is actuall called
    # "qmake-qt5" so adjust the qmake command as necessary.
    qmakeCmd = "qmake"
    if os.environ.get("DISTTAG") == "f27container":
        qmakeCmd = "qmake-qt5"
    qmakeArgs = [qmakeCmd, '-query', 'QT_INSTALL_HEADERS']

    qmake = Popen(qmakeArgs, stdout=PIPE)
    (out, err) = qmake.communicate()
    qmakeInstallHeaders = out.rstrip().decode("utf-8")
    extraincludes = [qmakeInstallHeaders, qmakeInstallHeaders + '/QtCore', qmakeInstallHeaders + '/QtNetwork', '../../lib']

    # Determine the special sip directory where qt sip files can be found. On
    # macOS and modern fedora images, this will be under /site-packages/, but
    # under /share/ in rhel.
    #
    # Note that we hardcode the root path in fedora images. In fedora27, we need
    # to explicitly use the python3 versioned path. In fedora35, the
    # get_python_lib() incorrectly returns "lib" rather than "lib64". The
    # distutils module the get_python_lib() is deprecated, so there's probably a
    # better way of getting the lib path.
    #
    specialsipdir = os.path.dirname(sipbin) + "/../share/sip/PyQt5"
    if (platform.system() == 'Darwin'):
        specialsipdir = "{}/PyQt5/bindings".format(get_python_lib())
    elif os.environ.get("DISTTAG") == "f27container":
        specialsipdir = "/usr/share/python3-sip/PyQt5"
    elif os.environ.get("DISTTAG") == "f35container":
        specialsipdir = "/usr/lib64/python3.10/site-packages/PyQt5/bindings"

else:
    config = pyqtconfig.Configuration()
    extraincludes = ['../..', config.qt_inc_dir + '/QtNetwork']

if (platform.system() == 'Linux'):
    config.default_mod_dir = '/$(prefix)/' + get_python_lib(1, 0, "")

config.default_sip_dir = '/$(prefix)/share/sip'

# Get the extra SIP flags needed by the imported PyQt modules.  Note that
# this normally only includes those flags (-x and -t) that relate to SIP's
# versioning system.
if useqt5:
    pyqt_sip_flags = pconfig['sip_flags']
else:
    pyqt_sip_flags = config.pyqt_sip_flags

# Run SIP to generate the code.  Note that we tell SIP where to find the qt
# module's specification files using the -I flag.
#if not os.path.exists("./sip"):
#    os.mkdir("./sip")

# convert the call to a subprocess call
#os.system(" ".join([config.sip_bin, "-e", "-c", "./sip", "-b", build_file, "-I", config.pyqt_sip_dir, pyqt_sip_flags, mylibSipFile]))

if useqt5:
    print(config.sip_bin, "-e -c . -w -b ", build_file, "-I", specialsipdir, pyqt_sip_flags, "-I..", mylibSipFile)
    retcode = call(" ".join([config.sip_bin, "-e", "-c", ".", "-w", "-b", build_file, "-I", specialsipdir, pyqt_sip_flags, "-I", "..", mylibSipFile]), shell=True)
else:
    retcode = call(" ".join([config.sip_bin, "-e", "-c", ".", "-w", "-b", build_file, "-I", config.pyqt_sip_dir, pyqt_sip_flags, "-I", "..", mylibSipFile]), shell=True)

if retcode < 0:
    sys.stderr.write("sip command was terminated by signal -{}".format(retcode))
    exit(retcode)
elif retcode > 0:
    sys.stderr.write("sip returned {}".format(retcode))
    exit(retcode)

# We are going to install the SIP specification file for this module and
# its configuration module.
installs = []

installs.append([mylibSipFile, os.path.join(config.default_sip_dir, "mylib")])
#installs.append(["../pyCodaConfig.py", config.default_mod_dir])

# Create the Makefile.  The QtCodaModuleMakefile class provided by the
# pyqtconfig module takes care of all the extra preprocessor, compiler and
# linker flags needed by the Qt library.
if useqt5:
    makefile = sipconfig.SIPModuleMakefile(
        configuration=config,
        build_file=build_file,
        installs=installs,
        makefile='./Makefile',
        warnings=0
    )
else:
    print(("This build file is ", build_file))
    makefile = pyqtconfig.QtCoreModuleMakefile(
        configuration=config,
        build_file=build_file,
        installs=installs,
        makefile='./Makefile',
        warnings=0
    )

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the "lib" prefix on UNIX, or the
# ".dll" extension on Windows).
extralibs = ["-L../../../build/lib"]
#print("Libdir: ", os.environ['LIBDIR'])
#try:
#    if (platform.system() == 'Darwin'):
#        makefile.extra_cxxflags = ["-F%s/Library/Frameworks" % (build.pkg_root('lts'))]
#    else:
#        extraincludes.append(build.pkg_inc('lts'))
#        extralibs.append(build.pkg_lib('lts'))
#except ValueError:
#    print("didn't find lts with pathfinder")
if (platform.system() == "Darwin"):
    extraincludes.append("/Library/Frameworks/lts.framework/Versions/Current/Headers")

makefile.extra_include_dirs = extraincludes
makefile.extra_lflags = extralibs

cxxflags_std = os.environ.get('CXXFLAGS_STD', "c++14")  # c++14
use_cxx11_abi = os.environ.get('GLIBCXX_USE_CXX11_ABI', "0")  # 0

makefile.extra_cxxflags = ["-std=" + cxxflags_std]
makefile.extra_cxxflags += ["-D_GLIBCXX_USE_CXX11_ABI=" + use_cxx11_abi]

if (platform.system() == 'Darwin'):
    makefile.extra_cxxflags += ["-mmacosx-version-min=10.15", "-fno-builtin-memcmp"]
    makefile.extra_lflags += ['-F../../mylib', '-framework Coda']
    makefile.extra_lflags += ["-mmacosx-version-min=10.15", "-stdlib=libc++"]
else:
    makefile.extra_cxxflags += ["-fno-builtin-memcmp"]
#    makefile.extra_lflags.append("-Wl,-rpath,\$$ORIGIN/../..")
#    makefile.extra_lflags.append("-Wl,-rpath,%s" % config.build_macros()['LIBDIR_QT'])
    makefile.extra_libs += ["mylib"]

# Generate the Makefile itself.
makefile.generate()

# Now we create the configuration module.  This is done by merging a Python
# dictionary (whose values are normally determined dynamically) with a
# (static) template.
content = {
    # Publish where the SIP specifications for this module will be
    # installed.
    "mylib_sip_dir":    config.default_sip_dir,

    # Publish the set of SIP flags needed by this module.  As these are the
    # same flags needed by the qt module we could leave it out, but this
    # allows us to change the flags at a later date without breaking
    # scripts that import the configuration module.
    "mylib_sip_flags":  pyqt_sip_flags
}

# This creates the helloconfig.py module from the helloconfig.py.in
# template and the dictionary.
#config = "../pyCodaConfig.py.in"
#if useqt5:
#    config = "../pyCodaConfig_qt5.py.in"
#sipconfig.create_config_module("../pyCodaConfig.py", config, content)
